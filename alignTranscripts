#!/usr/bin/env python

import os
import sys
import argparse
import string
import tempfile
import subprocess

LASTZ = 'lastz'
BEDTOOLS = 'bedtools'
FASTAFROMBED = 'fastaFromBed'
SHUFFLEBED = 'shuffleBed'
def checkDependencies():
	#check bedtools version
	cmd = [BEDTOOLS, '--version']
	try:
		out = subprocess.check_output(cmd)
	except:
		sys.exit("ERROR: bedtools not installed! You must have bedtools v2.17.0 or higher in your path! Exiting...")

	out = out.split()
	version = out[1][1:].split(".")
	if int(version[0]) > 2 or int(version[1]) < 17:
		sys.exit("ERROR: The version of bedtools you have installed is too old. You must have bedtools v2.17.0 or higher in your path! Exiting...")

	#check lastz
	cmd = [LASTZ, '--version']
	try:
		p = subprocess.Popen(cmd, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
	except:
		sys.exit("ERROR: lastz not installed! You must have lastz in your path! Exiting...")

	out = p.stdout.read()
	out = out.split()
	if out[0].strip() != "lastz":
		sys.exit("ERROR: lastz not installed! You must have lastz in your path! Exiting...")

def intArray(array):
	for i in range(len(array)):
		if array[i] != "": array[i] = int(array[i])
	return array

def convertToGeneCoords(base, exonSizes, exonStarts, numExons):
	block = 0
	for i in range(numExons):
		if base <= block + exonSizes[i]:
			newBase = exonStarts[i] + base - block
			break
		block += exonSizes[i]
	return newBase

def inExon(base, exonStarts, exonSizes, numExons, strand, geneSize):
	#print strand
	for i in range(numExons):
		if (base >= exonStarts[i] and base < (exonStarts[i] + exonSizes[i])):
			if strand == "+": return i+1
			else: return numExons-i
	return -1

def inIntron(base, exonStarts, exonSizes, numExons, strand, geneSize):
	#print strand
	for i in range(numExons-1):
		if (base > (exonStarts[i] + exonSizes[i]) and base < exonStarts[i+1]):
			return exonStarts[i+1] - (exonStarts[i] + exonSizes[i])
	return -1


def writePaddedBed(gene, pad):
	gene[1] = max(0, int(gene[1])-pad)
	gene[2] = int(gene[2])+pad
	
	tmpFd, tmpPath = tempfile.mkstemp()
	tmp = os.fdopen(tmpFd, 'w')
	tmp.write("%s\t%i\t%i\t%s\n" % (gene[0], gene[1], gene[2], gene[3]))
	return tmpPath

def writeBed(gene):
	tmpFd, tmpPath = tempfile.mkstemp()
	tmp = os.fdopen(tmpFd, 'w')
	tmp.write("%s" % gene[0])
	for i in range(11):
		tmp.write("\t%s" % gene[i+1])
	tmp.write("\n")
	return tmpPath

def getFa(bed, fasta):
	tmpFd, tmpPath = tempfile.mkstemp()
	#cmd = "%s -fi %s -bed %s -fo %s -name" % (FASTAFROMBED, fasta, bed, tmpPath)
	cmd = [FASTAFROMBED, "-fi", fasta, "-bed", bed, "-fo", tmpPath, "-name"]
	subprocess.check_call(cmd)
	return tmpPath

def alignFa(paddedAFaPath, paddedBFaPath, unmask, gap_open, gap_extend):
	tmpFd, tmpPath = tempfile.mkstemp()
	if unmask:
		cmd = [LASTZ, paddedAFaPath+"[unmask]", paddedBFaPath+"[unmask]", '--format=maf', '--output=%s' % tmpPath, '--chain', '--gap=%d,%d' %(gap_open, gap_extend)]
	else:
		cmd = [LASTZ, paddedAFaPath, paddedBFaPath, '--format=maf', '--output=%s' % tmpPath, '--chain', '--gap=%d,%d' %(gap_open, gap_extend)]
	
	nullFd, nullPath = tempfile.mkstemp()
	null = open(nullPath, 'w')

	subprocess.check_call(cmd, stderr = null)
	null.close()
	cmd = ['rm', nullPath]
	subprocess.check_call(cmd)

	return tmpPath

def categorizeLnc(alignments, numExonsA, numExonsB):
	exonsAlignedA = set()
	exonsAlignedB = set()
	maxExonId = 0
	maxIntronId = 0

	for a in alignments:
		for exon in a[6]: exonsAlignedA.add(exon)
		for exon in a[7]: exonsAlignedB.add(exon)
		if a[3] > maxExonId: 
			maxExonId = a[3]
			maxIntronId = a[5]
	
	if (len(exonsAlignedA) == 1 or len(exonsAlignedB) == 1) and (numExonsA!=1 and numExonsB!=1): 
		if maxExonId >=0.1: return "divergent"
		else: return "divergent/bad_alignment"
	if maxExonId < 0.1: return "mir_host/bad_alignment"
	if maxExonId >= 0.2:
		if maxIntronId >= 0.1: return "sno_host"
		else: return "intergenic"
	else:
		if maxIntronId >=0.05: return "sno_host"
		else: return "intergenic"

def main():
	parser = argparse.ArgumentParser(description='''
		Wrapper script for lastz to align two transcripts and report back exonic and sequence identity.\n
		If aligning non-coding genes, set --noncoding flag for more sensitive alignment.
	''')
	parser.add_argument('bedA', type=file,  help='bed file A')
	parser.add_argument('genomeFastaA', type=str, help='fasta file A')
	parser.add_argument('bedB', type=file, help='bed file B')
	parser.add_argument('genomeFastaB', type=str, help='fasta file B')
	parser.add_argument('out_prefix', type=str, help='out prefix')
	parser.add_argument('--geneA', type=str, help='if bedA has more than one entry, specify which gene to align')
	parser.add_argument('--geneB', type=str, help='if bedB has more than one entry, specify which gene to align')
	parser.add_argument('--pad', type=int, default=15000)
	parser.add_argument('--gap_open', type=int, default=250)
	parser.add_argument('--gap_extend', type=int, default=30)
	parser.add_argument('--unmask', action='store_true', help='unmask repeats when aligning')
	parser.add_argument('--bedtools_path', type=str)
	parser.add_argument('--lastz_path', type=str)
	parser.add_argument('--shuffle_bg', action='store_true', help='Aligns genes to random background and removes nonsignificant alignments')

	args = parser.parse_args()

	if args.bedtools_path is not None:
		global BEDTOOLS
		global FASTAFROMBED
		global SHUFFLEBED
		BEDTOOLS  = args.bedtools_path+"/bedtools"
		FASTAFROMBED = args.bedtools_path+"/fastaFromBed"
		SHUFFLEBED = args.bedtools_path+"shuffleBed"

	if args.lastz_path is not None:
		global LASTZ
		LASTZ = args.lastz_path+"/lastz"
	
	checkDependencies()

	genomeA = {}
	if os.path.exists(args.genomeFastaA+".fai"):
		genome = open(args.genomeFastaA+".fai", 'r')
		for line in genome.readlines():
			line = line.split()
			genomeA[line[0].strip()] = int(line[1])
	else:
		print "Fasta index for %s does not exist.  Please run samtools faidx %s. Exiting..." % (args.genomeFastaA, args.genomeFastaA)
		sys.exit(1)

	genomeB = {}
	if os.path.exists(args.genomeFastaB+".fai"):
		genome = open(args.genomeFastaB+".fai", 'r')
		for line in genome.readlines():
			line = line.split()
			genomeB[line[0].strip()] = int(line[1])
	else:
		print "Fasta index for %s does not exist.  Please run samtools faidx %s. Exiting..." % (args.genomeFastaB, args.genomeFastaB)
		sys.exit(1)

	alignment = open(args.out_prefix+".alignment_identity.txt", 'w')
	mafout = open(args.out_prefix+".maf", 'w')	
	#read in bed file A into array geneA
	geneA = []
	if args.geneA is None:
		geneA = args.bedA.readline().split()
	else:
		for line in args.bedA.readlines():
			if line.strip() == "": continue
			line = line.split()
			if (line[3].strip() == args.geneA.strip()): 
				geneA = line
				break
		if (len(geneA)==0):
			print "geneA %s not found! exiting..." % args.geneA
			sys.exit(1)

	#read in bed file B
	geneB = []
	if args.geneB is None:
		geneB = args.bedB.readline().split()
	else:
		for line in args.bedB.readlines():
			if line.strip() == "": continue
			line = line.split()
			if (line[3].strip() == args.geneB.strip()): 
				geneB = line
				break
		if (len(geneB)==0):
			print "geneB %s not found! exiting..." % args.geneB
			sys.exit(1)
	
	paddedABedPath = writePaddedBed(geneA, args.pad)
	paddedBBedPath = writePaddedBed(geneB, args.pad)

	paddedAFaPath = getFa(paddedABedPath, args.genomeFastaA)
	paddedBFaPath = getFa(paddedBBedPath, args.genomeFastaB)


	#MAKE BACKGROUND
	if args.shuffle_bg:
		shuffleScores = [0]

		bedB = writeBed(geneB)
		for i in range(10):
			#shuffle geneA
			cmd = [SHUFFLEBED, '-i', bedB, '-g', args.genomeFastaB+".fai"]
			shuffle = subprocess.check_output(cmd)
			shuffle = shuffle.split()
			paddedShuffleBed = writePaddedBed(shuffle, args.pad)
			paddedShuffleFa = getFa(paddedShuffleBed, args.genomeFastaB)
			
			#align geneA to shuffled
			mafPath = alignFa(paddedAFaPath, paddedShuffleFa, args.unmask, args.gap_open, args.gap_extend)
			mafFile = open(mafPath, 'r')
			maf = mafFile.readlines()
			for line in maf:
				if line.startswith("a"): shuffleScores.append(int(line.split("=")[1]))
			cmd = ['rm', mafPath, paddedShuffleBed, paddedShuffleFa]
			subprocess.check_call(cmd)

		bedA = writeBed(geneA)
		for i in range(10):
			#shuffle geneB
			cmd = [SHUFFLEBED, '-i', bedA, '-g', args.genomeFastaA+".fai"]
			shuffle = subprocess.check_output(cmd)
			shuffle = shuffle.split()
			paddedShuffleBed = writePaddedBed(shuffle, args.pad)
			paddedShuffleFa = getFa(paddedShuffleBed, args.genomeFastaA)
			
			#align geneB to shuffled
			mafPath = alignFa(paddedBFaPath, paddedShuffleFa, args.unmask, args.gap_open, args.gap_extend)
			mafFile = open(mafPath, 'r')
			maf = mafFile.readlines()
			for line in maf:
				if line.startswith("a"): shuffleScores.append(int(line.split("=")[1]))
			cmd = ['rm', mafPath, paddedShuffleBed, paddedShuffleFa]
			subprocess.check_call(cmd)

		cmd = ['rm', bedB, bedA]
		subprocess.check_call(cmd)

		maxShuffleScore = max(shuffleScores)
	#ALIGN GENES OF INTEREST
	mafPath = alignFa(paddedAFaPath, paddedBFaPath, args.unmask, args.gap_open, args.gap_extend)

	mafFile = open(mafPath, 'r')
	maf = mafFile.readlines()
	mafFile.close()

	cmd = ['rm', paddedABedPath, paddedBBedPath, paddedAFaPath, paddedBFaPath, mafPath]
	subprocess.check_call(cmd)	
	
	chrA = geneA[0].strip()
	geneAStart = int(geneA[1])+args.pad
	geneAEnd = int(geneA[2])-args.pad
	geneAName = geneA[3]
	strandA = geneA[5].strip()
	exonStartsA = intArray(geneA[11].split(','))
	exonSizesA = intArray(geneA[10].split(','))
	numExonsA = int(geneA[9])
	geneASize = geneAEnd - geneAStart
	exonASize = 0
	for i in range(numExonsA):
		exonASize += exonSizesA[i]
	intronASize = 0
	for i in range(numExonsA):
		intronASize += exonStartsA[i]

	chrB = geneB[0].strip()
	geneBStart = int(geneB[1])+args.pad
	geneBEnd = int(geneB[2])-args.pad
	geneBName = geneB[3]
	strandB = geneB[5].strip()
	if strandB == "*": strandB = "+"
	exonStartsB = intArray(geneB[11].split(','))
	exonSizesB = intArray(geneB[10].split(','))
	numExonsB = int(geneB[9])
	geneBSize = geneBEnd - geneBStart
	
	#CRAWL THROUGH ALIGNMENTS
	
	id = 0
	exonId = 0
	intronId = 0
	maxIntronId = 0
	maxIntronNum = 0
	stringB = ""
	stringA = ""
	baseB = -1
	baseA = -1
	truncA = ""
	truncB = ""
	truncAStart = -1
	truncBStart = -1
	exonsAlignedA = []
	exonsAlignedB = []
	alignments = []

	counter = 0
	

	for line in maf:
		line = line.strip()
		if line.startswith("#"): 
			mafout.write(line+"\n")

		if line.startswith("a"): 
			counter = counter + 1
			a = line
			score = int(line.split("=")[1])
		if line.startswith("s"):
			if stringA == "":
				sA = line.split()
				stringA = sA[6].strip()
				baseA = int(sA[2])
				dirA = sA[4].strip()
			else:
				sB = line.split()
				stringB = sB[6].strip()
				baseB = int(sB[2])
				dirB = sB[4].strip()

		#at line break, reset
		if line == "" and stringA !="":
			#print exonId, id
			if exonId == 0 and id == 0:
				counter = counter - 1
			else:
				if (args.shuffle_bg and score > maxShuffleScore) or (not args.shuffle_bg):
					if maxIntronNum ==0:
						#alignment.write("%d\t%s\t%s\t%0.3f\t%0.3f\tNA\t" % (counter, geneAName, geneBName, exonId / (exonASize*1.0), id / (geneASize*1.0)))
						alignments.append([counter, geneAName, geneBName, exonId / (exonASize*1.0), id / (geneASize*1.0), 'NA', exonsAlignedA, exonsAlignedB])
					else:
						#alignment.write("%d\t%s\t%s\t%0.3f\t%0.3f\t%0.3f\t" % (counter, geneAName, geneBName, exonId / (exonASize*1.0), id / (geneASize*1.0), maxIntronId / (maxIntronNum*1.0)))
						alignments.append([counter, geneAName, geneBName, exonId / (exonASize*1.0), id / (geneASize*1.0), maxIntronId / (maxIntronNum*1.0), exonsAlignedA, exonsAlignedB])
					
					#for i in exonsAlignedA:
					#	alignment.write("%d," % i)
					#alignment.write("\t")
					#for i in exonsAlignedB:
					#	alignment.write("%d," % i)
					#alignment.write("\n")
			
					#write maf
					mafout.write(a+"\n")
				
					if (dirA == "-"): truncAStart = genomeA[chrA] - truncAStart
					mafout.write("s %s %d %d %s %d %s\n" % (chrA, truncAStart, len(truncA.replace("-", "")), dirA, genomeA[chrA], truncA))
			
					if (dirB == "-"): truncBStart = genomeB[chrB] - truncBStart
					mafout.write("s %s %d %d %s %d %s\n" % (chrB, truncBStart, len(truncB.replace("-", "")), dirB, genomeB[chrB], truncB))
					
					mafout.write("\n")


			exonId = 0
			intronId = 0
			maxIntronId = 0
			maxIntronNum = 0
			id = 0
			score = 0
			stringB = ""
			stringA = ""
			truncA = ""
			truncB = ""
			truncAStart = -1
			truncBStart = -1
			exonsAlignedA = []
			exonsAlignedB = []

		if stringB != "" and stringA !="":
			for i in range(len(stringA)):
				if dirA == "+":
					baseARel = baseA - args.pad
					baseAGen = geneAStart - args.pad + baseA + 1
				else:
					baseARel = geneASize + args.pad - baseA
					baseAGen = geneAEnd + args.pad - baseA

				if dirB == "+":
					baseBRel = baseB - args.pad
					baseBGen = geneBStart - args.pad + baseB + 1
				else:
					baseBRel = geneBSize + args.pad - baseB
					baseBGen = geneBEnd + args.pad - baseB

				if baseARel >= -1000 and baseBRel >=-1000 and baseARel < geneASize+1000 and baseBRel < geneBSize+1000:
					if truncA == "":
						truncAStart = baseAGen
						truncBStart = baseBGen
					truncA += stringA[i]
					truncB += stringB[i]

				if stringB[i]==stringA[i] and baseARel >= 0 and baseARel < geneASize and stringB[i] != "-" and stringA[i]!="-" and baseBRel >= 0 and baseBRel < geneBSize:
					id += 1
					exonA = inExon(baseARel, exonStartsA, exonSizesA, numExonsA, strandA, geneASize) 
					exonB = inExon(baseBRel, exonStartsB, exonSizesB, numExonsB, strandB, geneBSize)
					if exonA != -1 and exonB!= -1:
						exonId += 1
						if exonA not in exonsAlignedA: exonsAlignedA.append(exonA)
						if exonB not in exonsAlignedB: exonsAlignedB.append(exonB)
						if intronId > maxIntronId:
							maxIntronId = intronId
							maxIntronNum = intronNum
						intronId = 0
					elif exonA == -1 and exonB == -1 and stringB[i].isupper() and stringA[i].isupper():
						intronId += 1
						intronNum = inIntron(baseARel, exonStartsA, exonSizesA, numExonsA, strandA, geneASize)
					else:
						if intronId > maxIntronId:
							maxIntronId = intronId
							maxIntronNum = intronNum
						intronId = 0

				else:
					if stringA[i] != "-" and stringB[i] !="-" and stringA[i].isupper() and stringB[i].isupper() and baseARel >= 0 and baseARel < geneASize and baseBRel >= 0 and baseBRel < geneBSize:
						intronId +=1
						intronNum = inIntron(baseARel, exonStartsA, exonSizesA, numExonsA, strandA, geneASize)
					else:
						if intronId > maxIntronId: 
							maxIntronId = intronId
							maxIntronNum = intronNum
						intronId = 0

				if stringB[i] !="-":
					baseB += 1

				if stringA[i] !="-": 
					baseA += 1
	category = categorizeLnc(alignments, numExonsA, numExonsB)
	
	alignment.write("alignmentID\tgeneA\tgeneB\texonID\tgeneID\tmaxContiguousIntron\texonsAlignedA\texonsAlignedB\tcategory\n")
	for a in alignments:
		alignment.write("%d\t%s\t%s\t%0.3f\t%0.3f\t%0.3f\t" % (a[0], a[1], a[2], a[3], a[4], a[5]))
		a[6].sort()
		a[7].sort()
		for exon in a[6]:
			alignment.write("%d," % exon)
		alignment.write("\t")
		for exon in a[7]:
			alignment.write("%d," % exon)
		alignment.write("\t")
		alignment.write("%s\n" % category)


if __name__ == "__main__":
	main()
